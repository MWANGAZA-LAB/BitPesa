generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum InvoiceStatus {
  PENDING
  PAID
  EXPIRED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  IN_FLIGHT
  SUCCEEDED
  FAILED
}

enum TransactionType {
  SEND_MONEY
  BUY_AIRTIME
  PAYBILL
  BUY_GOODS
  SCAN_PAY
}

enum TransactionStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
  LIGHTNING_PENDING
  LIGHTNING_PAID
  CONVERTING
  MPESA_PENDING
  REFUNDING
}

enum MpesaType {
  B2C
  AIRTIME
  PAYBILL
  TILL
}

enum MpesaStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

// Main Transaction model (no user context)
model Transaction {
  id                    String                @id @default(uuid())
  paymentHash           String                @unique
  transactionType       TransactionType
  status                TransactionStatus
  
  // Amounts
  btcAmount             Decimal               @db.Decimal(18, 8)
  kesAmount             Decimal               @db.Decimal(18, 2)
  exchangeRate          Decimal               @db.Decimal(18, 8)
  feeAmount             Decimal               @db.Decimal(18, 2)
  totalKesAmount        Decimal               @db.Decimal(18, 2)
  
  // M-Pesa Details
  recipientPhone        String
  recipientName         String?
  merchantCode          String?               // Paybill/Till number
  accountNumber         String?               // Paybill account
  referenceNumber       String?
  
  // Metadata
  ipAddress             String?
  userAgent             String?
  deviceInfo            Json?
  
  // Timestamps
  invoiceExpiresAt      DateTime
  paidAt                DateTime?
  completedAt           DateTime?
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  
  // Relations
  lightningInvoice      LightningInvoice?
  mpesaTransaction      MpesaTransaction[]
  
  // Performance-optimized indexes
  @@index([paymentHash])
  @@index([status])
  @@index([createdAt])
  @@index([recipientPhone])
  @@index([transactionType])
  @@index([status, createdAt]) // Composite index for status filtering with time sorting
  @@index([recipientPhone, status]) // Composite index for phone-based queries
  @@index([transactionType, status]) // Composite index for type-based filtering
  @@index([paymentHash, status]) // Composite index for payment hash lookups
  @@index([createdAt, status, transactionType]) // Composite index for complex queries
  @@index([invoiceExpiresAt]) // Index for expired invoice cleanup
  @@index([paidAt]) // Index for payment analytics
  @@index([completedAt]) // Index for completion analytics
  @@map("transactions")
}

// Lightning Invoice model
model LightningInvoice {
  id                  String              @id @default(uuid())
  paymentHash         String              @unique
  paymentRequest      String              @unique
  amountSats          BigInt
  amountKes           Decimal             @db.Decimal(18, 2)
  description         String?
  status              InvoiceStatus       @default(PENDING)
  expiresAt           DateTime
  paidAt              DateTime?
  preimage            String?
  
  transactionId       String              @unique
  transaction         Transaction         @relation(fields: [transactionId], references: [id])
  
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  
  // Performance-optimized indexes
  @@index([paymentHash])
  @@index([status])
  @@index([expiresAt])
  @@index([transactionId])
  @@index([status, expiresAt]) // Composite index for expired invoice cleanup
  @@index([paidAt]) // Index for payment analytics
  @@map("lightning_invoices")
}

// Lightning Payment model
model LightningPayment {
  id             String        @id @default(uuid())
  paymentHash    String
  paymentRequest String        @db.Text
  amountSats     BigInt
  feeSats        BigInt
  status         PaymentStatus @default(PENDING)
  failureReason  String?
  settledAt      DateTime?
  transactionId  String?       @unique
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  // Performance-optimized indexes
  @@index([status])
  @@index([paymentHash])
  @@index([transactionId])
  @@index([settledAt]) // Index for settlement analytics
  @@map("lightning_payments")
}

// M-Pesa Transaction model
model MpesaTransaction {
  id                    String              @id @default(uuid())
  transactionId         String
  transaction           Transaction         @relation(fields: [transactionId], references: [id])
  
  mpesaType             MpesaType
  merchantRequestId     String?
  checkoutRequestId     String?
  mpesaReceiptNumber    String?             @unique
  
  phoneNumber           String
  amount                Decimal             @db.Decimal(18, 2)
  businessShortCode     String?
  accountReference      String?
  
  status                MpesaStatus         @default(PENDING)
  resultCode            Int?
  resultDesc            String?
  
  callbackData          Json?
  requestData           Json?
  
  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt
  
  // Performance-optimized indexes
  @@index([transactionId])
  @@index([mpesaReceiptNumber])
  @@index([phoneNumber])
  @@index([status])
  @@index([mpesaType])
  @@index([merchantRequestId])
  @@index([checkoutRequestId])
  @@index([status, createdAt]) // Composite index for status filtering
  @@index([phoneNumber, status]) // Composite index for phone-based queries
  @@index([mpesaType, status]) // Composite index for type-based filtering
  @@map("mpesa_transactions")
}

// Exchange Rate model with caching optimization
model ExchangeRate {
  id            String    @id @default(uuid())
  fromCurrency  String    // BTC
  toCurrency    String    // KES
  rate          Decimal   @db.Decimal(18, 8)
  source        String    // binance, coinbase, etc
  spread        Decimal   @db.Decimal(18, 8)
  finalRate     Decimal   @db.Decimal(18, 8)
  validFrom     DateTime
  validUntil    DateTime
  createdAt     DateTime  @default(now())
  
  // Performance-optimized indexes
  @@index([fromCurrency, toCurrency])
  @@index([validFrom, validUntil])
  @@index([fromCurrency, toCurrency, validFrom, validUntil]) // Composite index for rate lookups
  @@index([source]) // Index for source-based queries
  @@index([createdAt]) // Index for cleanup operations
  @@map("exchange_rates")
}

// Performance metrics for monitoring
model PerformanceMetrics {
  id                  String   @id @default(uuid())
  serviceName         String
  endpoint            String?
  method              String?
  responseTime        Float
  statusCode          Int?
  errorCount          Int       @default(0)
  successCount        Int       @default(0)
  timestamp           DateTime  @default(now())
  
  // Performance-optimized indexes
  @@index([serviceName])
  @@index([timestamp])
  @@index([serviceName, timestamp]) // Composite index for service-specific metrics
  @@index([endpoint, timestamp]) // Composite index for endpoint-specific metrics
  @@index([statusCode, timestamp]) // Composite index for error analysis
  @@map("performance_metrics")
}

// Cache invalidation tracking
model CacheInvalidation {
  id          String   @id @default(uuid())
  cacheKey    String
  tags        String[] // Array of cache tags
  invalidatedAt DateTime @default(now())
  reason      String?
  
  // Performance-optimized indexes
  @@index([cacheKey])
  @@index([invalidatedAt])
  @@index([tags]) // GIN index for array operations
  @@map("cache_invalidations")
}
